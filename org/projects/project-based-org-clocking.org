#+STARTUP: showall indent
#+STARTUP: hidestars
#+BEGIN_HTML
---
layout: post
title: Automating my projects with org-mode
excerpt:
---
#+END_HTML
* Colors
#+BEGIN_SRC emacs-lisp
(defvar org-todo-colors-status-future "MediumSpringGreen")
(defvar org-todo-colors-status-current "DarkOrange1")
(defvar org-todo-colors-status-upcoming "DarkGoldenrod1")
(defvar org-todo-colors-status-urgent "red1")
(defvar org-todo-colors-status-completed "DarkTurquoise")
#+END_SRC

* Projects
Properties are the core object of my time-tracking system. They are how I organize what I can track time against and do billing with. +Unlike other org systems I want to keep my tasks seperate from my top-level project headers. This will allow me to cleanly seperate my projects from a variety of task files that relate to them.+

** Project File
Projects should be stored somewhere. I am going to store them in a central file.

#+BEGIN_SRC emacs-lisp
(defvar org-project-project-file (true-filename "~/.org/projects.org"))
#+END_SRC

** Project Properties
#+BEGIN_EXAMPLE
 *** Project Template
    :PROPERTIES:
    :BILLABLE: (t/f) if the project is billable
    :PERCENT: percent of billable time to use
    :CATEGORY: the major project code to be used for billing purposes
    :START_DATE: start date of project
    :END_DATE: end date of project (when to remove from clocking percent
    :GLOSSARY: The glossary of the key terms of the project for tagging notes and links
    :ID:  the UUID of an object
    :END:
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (defvar org-project-project-template
  "* %^{Project Stage|ONGOING|IDEA|GLIMMER|CAPTURE|LIVE|KICKOFF|STARTUP|ACTIVE|CLOSEOUT|DONE|CANCELED} %?
  :CONTACTS:\n:END:
  :LOGBOOK:
  - State \"CREATED\"       from \"NONE\"       %U
  :END:
  :PROPERTIES:
  :BILLABLE: %^{Billable?|y|n}
  :PERCENT: %^{Percent of Time}
  :CATEGORY: %^{Project Category}
  :START_DATE:
  :END_DATE:
  :GLOSSARY:
  :ID: %(org-id-uuid)
  :TYPE: project
  :END:"
  "Project Template for org-project")
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (setq org-todo-keyword-faces
          (append org-todo-keyword-faces
                  '(("ONGOING" :foreground org-todo-colors-status-current)
                    ("IDEA" :foreground org-todo-colors-status-future)
                    ("GLIMMER" :foreground org-todo-colors-status-future)
                    ("CAPTURE" :foreground org-todo-colors-status-upcoming :weight bold)
                    ("LIVE" :foreground org-todo-colors-status-upcoming :weight bold)
                    ("KICKOFF" :foreground org-todo-colors-status-urgent :weight bold)
                    ("STARTUP" :foreground org-todo-colors-status-current :weight bold)
                    ("ACTIVE" :foreground org-todo-colors-status-current :weight bold)
                    ("CLOSEOUT" :foreground org-todo-colors-status-urgent :weight bold)
                    ("DONE" :foreground org-todo-colors-status-completed)
                    ("CANCELED" :foreground org-todo-colors-status-completed))
#+END_SRC

** Project States
Projects follow a basic set of project stages so that I can keep track of the progression of a project in the future.
- Ongoing: These are projects that never end. Like fund-raising, administration, etc.
- Idea: This state is saved for ideas for projects that have not yet gelled into full projects, and have no identified funding opportunity.
- Glimmer: These are projects that have are more fleshed out, but only have a possible future funding line identified.
- Capture: These are projects that have an
- Live: When a RFP has dropped and we are exploring the project.
- Kickoff:
- Startup: The actual start up of the project once funding has been received.
- Active: The actual project management portion of the project.
- Closeout: The closeout of the project and sunsetting of technical componenets.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-todo-keywords
               '(sequence "ONGOING" "IDEA(!)" "GLIMMER(!)" "CAPTURE(!)" "LIVE(!)" "KICKOFF(!)" "STARTUP(!)" "ACTIVE(!)" "CLOSEOUT(!)" "|" "DONE(d!)" "CANCELED(@!)"))
#+END_SRC

** TODO Identifying active projects
#+BEGIN_SRC emacs-lisp
  (defun org-projects-get-projects-all ()
    (org-map-entries (nth 4 (org-heading-components)) t '(org-project-project-file)))

;; A helm source for my projects
;; http://kitchingroup.cheme.cmu.edu/blog/2015/01/24/Anatomy-of-a-helm-source/

  (defun prompt-for-current-projects ()
    (helm :sources '(org-projects-helm-source-current-projects)))

  (defun org-projects-get-projects-current ()
    (org-map-entries (nth 4 (org-heading-components)) "TODO=ACTIVE|TODO=STARTUP|TODO=CLOSEOUT|TODO=ONGOING" '(org-project-project-file)))

  (setq org-projects-helm-source-current-projects
        '((name . "Get current projects using helm.")
          (candidates . org-projects-get-projects-current)
          (action . (lambda (candidate)
                      candidate))))


  (defun prompt-for-current-projects-category ()
    (helm :sources '(org-projects-helm-source-current-projects-category))))

  (defun org-projects-get-project-category-current ()
    (org-map-entries '(let ((category (org-entry-get (point) "CATEGORY"))
                            (name (nth 4 (org-heading-components))))
                        (cons name category)) "TODO=ACTIVE|TODO=STARTUP|TODO=CLOSEOUT|TODO=ONGOING" '(org-project-project-file)))

  (setq org-projects-helm-source-current-projects-category
        '((name . "Get current projects using helm.")
          (candidates . org-projects-get-project-category-current)
          (action . (lambda (candidate)
                      candidate))))

#+END_SRC

** TODO Project directories and projectile
* Tasks
** Task File
Tasks should be stored seperate from projects

#+BEGIN_SRC emacs-lisp
(defvar org-project-tasks-file (true-filename "~/.org/tasks.org"))
#+END_SRC

** Task helpers

** Types of tasks
#+BEGIN_EXAMPLE
 *** TODO
    SCHEDULED: <2015-06-19 Fri> DEADLINE: <2015-06-19 Fri>
    :PROPERTIES:
    :CATEGORY: the major project code to be used for billing purposes
    :ID:  the UUID of an object
    :WITH:
    :AT:
    :EFFORT:
    :STATUS:
    :TYPE:
    :STAGE: The stage of the project to activate this task if it is to be delayed.
    :END:
 *** ACTIVE
    SCHEDULED: <2015-06-19 Fri> DEADLINE: <2015-06-19 Fri>
    :PROPERTIES:
    :CATEGORY: the major project code to be used for billing purposes
    :ID:  the UUID of an object
    :WITH:
    :AT:
    :EFFORT:
    :STATUS:
    :TYPE:
    :END:
 *** CLOSED
    SCHEDULED: <2015-06-19 Fri> DEADLINE: <2015-06-19 Fri>
    :PROPERTIES:
    :CATEGORY: the major project code to be used for billing purposes
    :ID:  the UUID of an object
    :WITH:
    :AT:
    :EFFORT:
    :STATUS:
    :TYPE:
    :END:
 *** WAIT
    :PROPERTIES:
    :CATEGORY: the major project code to be used for billing purposes
    :ID:  the UUID of an object
    :WITH:
    :AT:
    :EFFORT:
    :STATUS:
    :TYPE:
    :END:
#+END_EXAMPLE

Task capture  templates
#+BEGIN_SRC emacs-lisp
  (defvar org-project-task-template-todo
  "* TODO %?
  :LOGBOOK:
  - State \"CREATED\"       from \"NONE\"       %U
  :END:
  :PROPERTIES:
  :CATEGORY: %(prompt-for-current-projects-category)
  :EFFORT: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :ID: %(org-id-uuid)
  :ASSIGNED:
  :IMPORTANCE:
  :URGENCY:
  :WITH: %(org-projects-helm-contacts-source)
  :AT:
  :STATE: todo
  :TYPE: task
  :END:"
  "TODO Template for org-project")

  (defvar org-project-task-template-active
  "* ACTIVE %?
  :LOGBOOK:
  - State \"CREATED\"       from \"NONE\"       %U
  :END:
  :PROPERTIES:
  :CATEGORY: %(prompt-for-current-projects-category)
  :EFFORT: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :ID: %(org-id-uuid)
  :ASSIGNED:
  :IMPORTANCE:
  :URGENCY:
  :WITH: %(org-projects-helm-contacts-source)
  :AT:
  :STATUS: active
  :TYPE:
  :END:"
  "ACTIVE Template for org-project")

  (defvar org-project-task-template-contact
  "* CONTACT RE: %?
  :LOGBOOK:
  - State \"CREATED\"       from \"NONE\"       %U
  :END:
  :PROPERTIES:
  :CATEGORY: %(prompt-for-current-projects-category)
  :EFFORT: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :ID: %(org-id-uuid)
  :IMPORTANCE:
  :URGENCY:
  :WHO: %(org-project-helm-prompt-for-org-contact)
  :STATUS: active
  :TYPE: task
  :END:"
  "CONTACT Template for org-project")

  (defvar org-project-task-template-wait
  "* WAIT RE: %?
  :LOGBOOK:
  - State \"CREATED\"       from \"NONE\"       %U
  :END:
  :PROPERTIES:
  :CATEGORY: %(prompt-for-current-projects-category)
  :ID: %(org-id-uuid)
  :IMPORTANCE:
  :URGENCY:
  :FROM: %(org-project-helm-prompt-for-org-contact)
  :STATUS: active
  :TYPE: task
  :END:"
  "WAIT Template for org-project")

  (defvar org-project-task-template-closed
  "* %^{STATUS|DONE|SOMEDAY|CANCELED|FAILED} %?
  :PROPERTIES:
  :CATEGORY: %(prompt-for-current-projects-category)
  :EFFORT: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :ID: %(org-id-uuid)
  :ASSIGNED:
  :IMPORTANCE:
  :URGENCY:
  :AT:
  :STATUS: closed
  :TYPE: task
  :END:"
  "CLOSED Template for org-project")
#+END_SRC
Task faces
#+BEGIN_SRC emacs-lisp
    (setq org-todo-keyword-faces
          (append org-todo-keyword-faces
                  '(("TODO" :foreground org-todo-colors-status-urgent)
                    ("ACTIVE" :foreground org-todo-colors-status-current)
                    ("CONTACT" :foreground org-todo-colors-status-current)
                    ("WAIT" :foreground org-todo-colors-status-upcoming :weight bold)
                    ("DONE" :foreground org-todo-colors-status-completed :weight bold)
                    ("SOMEDAY" :foreground org-todo-colors-status-completed :weight bold)
                    ("CANCELED" :foreground org-todo-colors-status-completed :weight bold)
                    ("FAILED" :foreground org-todo-colors-status-completed :weight bold))))
#+END_SRC

** Task States

*** Basic Tasks
TODO keywords and workflow
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-todo-keywords
               '(sequence "TODO(t!)" "CONTACT(c!)" "ACTIVE(a!)" "WAIT(w/!)" "|" "DONE(d!)" "SOMEDAY(s!)" "CANCELED(C!)" "FAILED(f!)"))
#+END_SRC

*** Updating a tasks status when states change

This is how I ensure that my status objects are updated

#+BEGIN_SRC emacs-lisp

  (setq org-project-task-states
        '(("active" . ("ACTIVE" "WAIT" "REPLY"))
         ("todo" . ("TODO" "CONTACT"))
         ("closed" . ("FAILED" "CANCELED" "SOMEDAY" "DONE"))))

  (defun org-project-task-update-status-on-todo-changes ()
    "Update the state property for a task to represent complex states.
     Hook function for 'org-after-todo-state-change-hook'
     Check the org-project-task-states to see if the current state is one that"
    (if (equal (org-entry-get (point) "TYPE") "task")
    (let ((check-states org-project-task-states))
      (while check-states
        (let ((cur-state (car check-states)))
          (if (member org-state (cdr cur-state))
              (org-entry-put (point) "STATUS" (car cur-state))))
          (setq check-states (cdr check-states))))))

  (add-hook 'org-after-todo-state-change-hook
            'org-project-task-update-status-on-todo-changes)
#+END_SRC

* Events

** Events File
Task File
Tasks should be stored seperate from projects

#+BEGIN_SRC emacs-lisp
(defvar org-project-tasks-file (true-filename "~/.org/tasks.org"))
#+END_SRC

** Event Properties
#+BEGIN_EXAMPLE
 *** EVENT
    :PROPERTIES:
    :CATEGORY: the major project code to be used for billing purposes
    :ID:  the UUID of an object
    :WITH:
    :AT:
    :EFFORT:
    :STATUS:
    :TYPE:
    :END:
 *** MEET about TASK
    :PROPERTIES:
    :CATEGORY: the major project code to be used for billing purposes
    :ID:  the UUID of an object
    :WITH: [CONTACT(s)]
    :AT:
    :EFFORT:
    :STATUS:
    :TYPE:
    :END:
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
  (defvar org-project-task-template-meet
  "* MEET about %?
  :PROPERTIES:
  :CATEGORY: %(prompt-for-current-projects-category)
  :EFFORT: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :ID: %(org-id-uuid)
  :ASSIGNED:
  :IMPORTANCE:
  :URGENCY:
  :WITH: %(org-project-helm-prompt-for-org-contact)
  :STATUS: active
  :TYPE: event
  :END:"
  "Task Template for org-project")

  (defvar org-project-task-template-event
  "* EVENT
   SCHEDULED:  %^t
  :PROPERTIES:
  :CATEGORY: %(prompt-for-current-projects-category)
  :EFFORT: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :ID: %(org-id-uuid)
  :ASSIGNED:
  :IMPORTANCE:
  :URGENCY:
  :WITH: %(org-project-helm-prompt-for-org-contact)
  :STATUS: todo
  :TYPE: event
  :END:"
  "Task Template for org-project")
#+END_SRC

#+BEGIN_SRC emacs-lisp
      (setq org-todo-keyword-faces
            (append org-todo-keyword-faces
                    '(("EVENT" :foreground org-todo-colors-status-upcoming :weight bold)
                      ("MEET" :foreground org-todo-colors-status-current))))
#+END_SRC

* Email
** TODO Received new message
*** If encrypted
**** decrypt for parsing
*** get projects
**** get project glossaries
***** check content and subject for terms
***** tag to project if found
**** check from, cc & to for group memebers
***** tag to project if found
** TODO Open a message
*** Create an org entry of the email
*** Add project category to entry from message tag
*** Start clocking to the message
*** Create global variable of message that was opened (so that when we stop clocking we don't have to query the original message that opened the thread)
*** decrypt message
** TODO Close a message
*** If clocking this message,
**** Stop clocking and close the message.
*** If not clocking for some reason
**** Close the message without closing current clock
** TODO Reply to a message
*** Create an org-entry for the reply
**** Add project category to entry from message tag
**** Temporary ID created and stored in global value list
*** If adding contacts
**** helm-contacts uses tags and members of the thread to give a sub-list of probable contacts
** TODO Send Reply
*** Check to,cc,bcc contacts
**** If contact in to,cc,or bcc requires encryption
***** Encrypt message
*** Get message ID from server and replace temporary ID with that ID
*** Stop clocking
** TODO Close reply without sending
*** stop clocking
* Capture
** Adding/Capturing Objects
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        `(("p" "Projects")
          ("pc" "Create Project" entry (file org-project-project-file)
            ,org-project-project-template :clock-in t :clock-resume t)
          ("t" "Tasks")
          ("tt" "Create TODO" entry (file org-project-tasks-file)
            ,org-project-task-template-todo :clock-in t :clock-resume t)
          ("ta" "Create ACTIVE" entry (file org-project-tasks-file)
            ,org-project-task-template-active :clock-in t :clock-resume t)
          ("tc" "Create CONTACT" entry (file org-project-tasks-file)
            ,org-project-task-template-contact :clock-in t :clock-resume t)
          ("tw" "Create WAIT" entry (file org-project-tasks-file)
            ,org-project-task-template-wait :clock-in t :clock-resume t)
          ("tC" "Create Closed" entry (file org-project-tasks-file)
            ,org-project-task-template-closed :clock-in t :clock-resume t)
          ("e" "Events")
          ("ee" "Create EVENT" entry (file org-project-events-file)
            ,org-project-task-template-event :clock-in t :clock-resume t)
          ("em" "Create MEETING" entry (file org-project-events-file)
            ,org-project-task-template-meet :clock-in t :clock-resume t)))
#+END_SRC
** Archiving Objects
*** Projects
*** Tasks
*** Events
** Workflow
*** TODO prompt for TODO Item
*** TODO Create entry
*** TODO prompt for project
**** TODO Add project category to entry
*** TODO If capture requires a "with" entry
**** create helm-contacts list to choose from
* Contacts
** Helm Search for contacts
This searches the org-contacts file and returns the name of the contact.
#+BEGIN_SRC emacs-lisp
    (defun org-projects-helm-get-contacts ()
      (org-map-entries '(let ((email (org-entry-get (point) "EMAIL"))
                              (name (nth 4 (org-heading-components))))
                          (cons (concat name " ( " email " ) ") name)) t '(org-contacts-files)))

      (setq org-projects-helm-contacts-source
              `((name . "Helm capture for Org-Contacts")
                (candidates . org-projects-helm-get-contacts)
                (action . (lambda (candidate)
                            (mapconcat 'identity (helm-marked-candidates) ", ")))))

      (defun helm-prompt-for-current-org-contact ()
            (interactive)
            (helm :sources '(org-projects-helm-contacts-source)))
#+END_SRC
*** TODO How do I use helm in capture templates
This is just a quick function to remind me that I have to figure out how to use helm in capture templates.
#+BEGIN_SRC emacs-lisp
  (defun org-project-task-template-contacts-test ()
      (interactive)
      (format "* TODO DELETE THIS TEST
    SCHEDULED: %t
    :PROPERTIES:
    :CONTACTS: %s
    :TYPE: test
    :END:" (mapconcat 'identity (prompt-for-current-org-contact) ", ")))

  (defun org-projects-get-clean-contacts-list ()
              (mapconcat 'identity (prompt-for-current-org-contact) ", "))
#+END_SRC

** TODO Contacts tagged with projects and teams that they are involved in
** TODO contacts with "encrypt" category force encryption of messages sent to them
